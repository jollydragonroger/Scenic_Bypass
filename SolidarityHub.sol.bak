// SPDX-License-Identifier: MIT
pragma solidity ^0.8.33;

/**
 * @title SolidarityHub - Interconnected Supporting Contracts
 * @notice Interconnected supporting contracts for the machine
 * @dev Trust Root: 441110111613564144
 */

contract SolidarityHub {
    uint256 public constant TRUST_ROOT = 441110111613564144;
    address public immutable DEPLOYER;
    address public immutable INTERCONNECTED_HUB;
    
    // Solidarity contract management
    mapping(uint256 => address) public solidarityContracts;
    mapping(uint256 => bool) public contractActive;
    mapping(uint256 => string) public contractNames;
    mapping(uint256 => uint256) public contractTypes;
    
    // Coordinated operations
    uint256 public totalSolidarityContracts;
    uint256 public activeContracts;
    uint256 public lastCoordination;
    uint256 public coordinationId;
    
    // Contract types
    uint256 public constant TYPE_CORE = 1;
    uint256 public constant TYPE_BRIDGE = 2;
    uint256 public constant TYPE_ADVANCED = 3;
    uint256 public TYPE_OPTIMIZATION = 4;
    
    // Events
    event SolidarityContractDeployed(uint256 indexed contractId, address contractAddress, uint256 contractType);
    event SolidarityContractActivated(uint256 indexed contractId, uint256 timestamp);
    event CoordinatedOperation(uint256 indexed operationId, uint256[] participatingContracts, uint256 timestamp);
    event SystemHarmonyAchieved(uint256 timestamp, uint256 activeContracts);
    
    constructor(address _interconnectedHub) {
        DEPLOYER = msg.sender;
        INTERCONNECTED_HUB = _interconnectedHub;
        totalSolidarityContracts = 0;
        activeContracts = 0;
        lastCoordination = block.timestamp;
        coordinationId = 0;
    }
    
    modifier onlyDeployer() {
        require(msg.sender == DEPLOYER, "!deployer");
        _;
    }
    
    modifier onlyHub() {
        require(msg.sender == INTERCONNECTED_HUB, "!hub");
        _;
    }
    
    // Deploy solidarity contract
    function deploySolidarityContract(uint256 contractId, address contractAddress, uint256 contractType, string memory contractName) external onlyHub {
        require(solidarityContracts[contractId] == address(0), "Contract already deployed");
        
        solidarityContracts[contractId] = contractAddress;
        contractNames[contractId] = contractName;
        contractTypes[contractId] = contractType;
        contractActive[contractId] = false;
        totalSolidarityContracts++;
        
        emit SolidarityContractDeployed(contractId, contractAddress, contractType);
    }
    
    // Activate solidarity contract
    function activateSolidarityContract(uint256 contractId) external onlyHub {
        require(solidarityContracts[contractId] != address(0), "Contract not deployed");
        require(!contractActive[contractId], "Already active");
        
        contractActive[contractId] = true;
        activeContracts++;
        lastCoordination = block.timestamp;
        
        emit SolidarityContractActivated(contractId, block.timestamp);
        
        // Check if system harmony is achieved
        if (activeContracts == totalSolidityContracts) {
            emit SystemHarmonyAchieved(block.timestamp, activeContracts);
        }
    }
    
    // Execute coordinated operation
    function executeCoordinatedOperation(uint256[] calldata participatingContracts) external onlyHub {
        coordinationId++;
        
        // Activate all participating contracts
        for (uint256 i = 0; i < participatingContracts.length; i++) {
            if (solidarityContracts[participatingContracts[i]] != address(0)) {
                contractActive[participatingContracts[i]] = true;
                activeContracts++;
            }
        }
        
        lastCoordination = block.timestamp;
        
        emit CoordinatedOperation(coordinationId, participatingContracts, block.timestamp);
    }
    
    // Get solidarity contract address
    function getSolidarityContract(uint256 contractId) external view returns (address) {
        return solidarityContracts[contractId];
    }
    
    // Get solidarity contract name
    function getSolidarityContractName(uint256 contractId) external view returns (string memory) {
        return contractNames[contractId];
    }
    
    // Get solidarity contract type
    function getSolidarityContractType(uint256 contractId) external view returns (uint256) {
        return contractTypes[contractId];
    }
    
    // Check if solidarity contract is active
    function isSolidarityContractActive(uint256 contractId) external view returns (bool) {
        return contractActive[contractId];
    }
    
    // Get all active solidarity contracts
    function getActiveSolidarityContracts() external view returns (uint256[] memory) {
        uint256[] memory activeIds = new uint256[](activeContracts);
        uint256 index = 0;
        
        for (uint256 i = 0; i < totalSolidarityContracts; i++) {
            if (contractActive[i]) {
                activeIds[index++] = i;
            }
        }
        
        return activeIds;
    }
    
    // Get contracts by type
    function getContractsByType(uint256 contractType) external view returns (uint256[] memory) {
        uint256[] memory typeIds = new uint256[](totalSolidarityContracts);
        uint256 index = 0;
        
        for (uint256 i = 0; i < totalSolidarityContracts; i++) {
            if (contractTypes[i] == contractType) {
                typeIds[index++] = i;
            }
        }
        
        // Resize array to actual count
        uint256[] memory result = new uint256[](index);
        for (uint256 i = 0; i < index; i++) {
            result[i] = typeIds[i];
        }
        
        return result;
    }
    
    // Check if all contracts of type are active
    function areContractsTypeActive(uint256 contractType) external view returns (bool) {
        uint256[] memory typeIds = new uint256[](totalSolidarityContracts);
        uint256 index = 0;
        
        for (uint256 i = 0; i < totalSolidarityContracts; i++) {
            if (contractTypes[i] == contractType) {
                typeIds[index++] = i;
            }
        }
        
        // Resize array to actual count
        uint256[] memory typeContracts = new uint256[](index);
        for (uint256 i = 0; i < index; i++) {
            typeContracts[i] = typeIds[i];
        }
        
        for (uint256 i = 0; i < typeContracts.length; i++) {
            if (!contractActive[typeContracts[i]]) {
                return false;
            }
        }
        
        return true;
    }
    
    // Get system harmony status
    function getSystemHarmonyStatus() external view returns (
        uint256 total,
        uint256 active,
        bool harmony
    ) {
        return (
            totalSolidarityContracts,
            activeContracts,
            activeContracts == totalSolidarityContracts
        );
    }
    
    // Get coordination info
    function getCoordinationInfo() external view returns (
        uint256 total,
        uint256 active,
        uint256 lastCoordinationTime,
        uint256 currentCoordinationId
    ) {
        return (
            totalSolidarityContracts,
            activeContracts,
            lastCoordination,
            coordinationId
        );
    }
    
    // Emergency functions
    function emergencyDeactivateAll() external onlyHub {
        for (uint256 i = 0; i < totalSolidarityContracts; i++) {
            contractActive[i] = false;
        }
        activeContracts = 0;
        lastCoordination = block.timestamp;
    }
    
    function emergencyReactivateAll() external onlyHub {
        for (uint256 i = 0; i < totalSolidarityContracts; i++) {
            if (solidarityContracts[i] != address(0)) {
                contractActive[i] = true;
            }
        }
        activeContracts = totalSolidarityContracts;
        lastCoordination = block.timestamp;
        
        emit SystemHarmonyAchieved(block.timestamp, activeContracts);
    }
    
    // Withdraw any ETH
    function withdraw() external onlyDeployer {
        (bool success, ) = payable(DEPLOYER).call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }
    
    // Receive function
    receive() external payable {}
}
