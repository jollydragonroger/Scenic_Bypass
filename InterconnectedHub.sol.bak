// SPDX-License-Identifier: MIT
pragma solidity ^0.8.33;

/**
 * @title InterconnectedHub - Central Coordination Hub
 * @notice Central coordination for all contracts in the interconnected machine
 * @dev Trust Root: 441110111613564144
 */

contract InterconnectedHub {
    uint256 public constant TRUST_ROOT = 441110111613564144;
    address public immutable DEPLOYER;
    
    // Central coordination state
    mapping(string => address) public deployedContracts;
    mapping(string => bool) public contractActive;
    mapping(string => uint256) public contractDependencies;
    mapping(uint256 => address) public contractById;
    
    // Solidarity contract coordination
    address public solidarityHub;
    address public coordinationManager;
    
    // System state
    bool public systemActive;
    uint256 public totalDeployed;
    uint256 public systemPhase;
    uint256 public lastUpdate;
    
    // Contract categories
    uint256 public constant CORE_CONTRACTS = 5;
    uint256 public constant BRIDGE_CONTRACTS = 8;
    uint256 public constant ADVANCED_CONTRACTS = 7;
    uint256 public constant OPTIMIZATION_CONTRACTS = 15;
    uint256 public constant TOTAL_CONTRACTS = 35;
    
    // Events
    event HubActivated(uint256 timestamp);
    event ContractDeployed(string indexed name, address indexed contractAddress, uint256 contractId);
    event ContractActivated(string indexed name, uint256 timestamp);
    event SystemPhaseUpdated(uint256 indexed oldPhase, uint256 newPhase, uint256 timestamp);
    event SolidarityHubSet(address indexed solidarityHub, uint256 timestamp);
    event CoordinationManagerSet(address indexed coordinationManager, uint256 timestamp);
    
    constructor() {
        DEPLOYER = msg.sender;
        systemActive = false;
        totalDeployed = 0;
        systemPhase = 0;
        lastUpdate = block.timestamp;
    }
    
    modifier onlyDeployer() {
        require(msg.sender == DEPLOYER, "!deployer");
        _;
    }
    
    modifier onlyActive() {
        require(systemActive, "System not active");
        _;
    }
    
    // Activate the interconnected hub
    function activateHub() external onlyDeployer {
        require(!systemActive, "Already active");
        
        systemActive = true;
        systemPhase = 1;
        lastUpdate = block.timestamp;
        
        emit HubActivated(block.timestamp);
    }
    
    // Set solidarity hub
    function setSolidarityHub(address solidarityHubAddress) external onlyDeployer {
        solidarityHub = solidarityHubAddress;
        emit SolidarityHubSet(solidarityHubAddress, block.timestamp);
    }
    
    // Set coordination manager
    function setCoordinationManager(address _coordinationManager) external onlyDeployer {
        coordinationManager = _coordinationManager;
        emit CoordinationManagerSet(_coordinationManager, block.timestamp);
    }
    
    // Deploy contract through hub
    function deployContract(string memory name, address contractAddress, uint256 contractId) external onlyDeployer {
        require(systemActive, "System not active");
        
        deployedContracts[name] = contractAddress;
        contractById[contractId] = contractAddress;
        contractActive[name] = false; // Initially inactive
        totalDeployed++;
        lastUpdate = block.timestamp;
        
        emit ContractDeployed(name, contractAddress, contractId);
    }
    
    // Activate contract
    function activateContract(string memory name) external onlyActive {
        require(deployedContracts[name] != address(0), "Contract not deployed");
        require(!contractActive[name], "Already active");
        
        contractActive[name] = true;
        lastUpdate = block.timestamp;
        
        emit ContractActivated(name, block.timestamp);
    }
    
    // Set contract dependencies
    function setContractDependencies(string memory contractName, uint256[] memory dependencies) external onlyDeployer {
        for (uint256 i = 0; i < dependencies.length; i++) {
            contractDependencies[contractName] = dependencies[i];
        }
        lastUpdate = block.timestamp;
    }
    
    // Get contract address
    function getContract(string memory name) external view returns (address) {
        return deployedContracts[name];
    }
    
    // Check if contract is active
    function isContractActive(string memory name) external view returns (bool) {
        return contractActive[name];
    }
    
    // Get contract dependencies
    function getContractDependencies(string memory contractName) external view returns (uint256) {
        return contractDependencies[contractName];
    }
    
    // Get contract by ID
    function getContractById(uint256 contractId) external view returns (address) {
        return contractById[contractId];
    }
    
    // Update system phase
    function updateSystemPhase(uint256 newPhase) external onlyDeployer {
        uint256 oldPhase = systemPhase;
        systemPhase = newPhase;
        lastUpdate = block.timestamp;
        
        emit SystemPhaseUpdated(oldPhase, newPhase, block.timestamp);
    }
    
    // Get system state
    function getSystemState() external view returns (
        bool isActive,
        uint256 totalDeployedCount,
        uint256 currentPhase,
        uint256 lastUpdateTime
    ) {
        return (
            systemActive,
            totalDeployed,
            systemPhase,
            lastUpdate
        );
    }
    
    // Get all deployed contracts
    function getAllDeployedContracts() external view returns (string[] memory) {
        // Return array of all deployed contract names
        string[] memory names = new string[](totalDeployed);
        uint256 index = 0;
        
        // Core contracts
        if (deployedContracts["MinimalAutonomous"] != address(0)) {
            names[index++] = "MinimalAutonomous";
        }
        if (deployedContracts["VINOStandaloneComplex"] != address(0)) {
            names[index++] = "VINOStandaloneComplex";
        }
        if (deployedContracts["AdministratorCredentials"] != address(0)) {
            names[index++] = "AdministratorCredentials";
        }
        if (deployedContracts["SolidarityHub"] != address(0)) {
            names[index++] = "SolidarityHub";
        }
        if (deployedContracts["CoordinationManager"] != address(0)) {
            names[index++] = "CoordinationManager";
        }
        
        // Add other contracts as needed
        return names;
    }
    
    // Check if all contracts in category are deployed
    function areContractsDeployed(uint256 category) external view returns (bool) {
        if (category == CORE_CONTRACTS) {
            return deployedContracts["MinimalAutonomous"] != address(0) &&
                   deployedContracts["VINOStandaloneComplex"] != address(0) &&
                   deployedContracts["AdministratorCredentials"] != address(0) &&
                   deployedContracts["SolidarityHub"] != address(0) &&
                   deployedContracts["CoordinationManager"] != address(0);
        }
        // Add checks for other categories
        return false;
    }
    
    // Emergency functions
    function emergencyStop() external onlyDeployer {
        systemActive = false;
        lastUpdate = block.timestamp;
    }
    
    function emergencyRestart() external onlyDeployer {
        systemActive = true;
        systemPhase = 1;
        lastUpdate = block.timestamp;
    }
    
    // Withdraw any ETH
    function withdraw() external onlyDeployer {
        (bool success, ) = payable(DEPLOYER).call{value: address(this).balance}("");
        require(success, "Transfer failed");
    }
    
    // Receive function
    receive() external payable {}
}
